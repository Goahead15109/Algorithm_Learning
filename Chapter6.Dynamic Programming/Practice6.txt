习题6
1.动态规划法为什么都需要填表？如何设计表格的结构？
分析：动态规划法将待求解问题分解成若干个相互重叠的子问题，每个子问题对应决策过程的一个阶段，
一般来说，子问题的重叠关系表现在对给定问题的求解的递推关系（动态规划函数）中，将子问题的解
求解一次并填入表中，当需要再次求解该子问题时，可以通过查表获得该子问题的解，从而避免了大量
重复计算。    设计表结构，以自底向上的方式计算各个子问题的解并填表。
2.多段图最短路径问题
填表：
下标i			0	1	2	3	4	5	6	7	8	9	10	11	12
元素值d(0,i)	0	5	3	6	8	10	9	11	13	13	14	15	18
d(0,0) = 0;

d(0,1) = d(0,0) + c01 = 5
d(0,2) = d(0,0) + c02 = 3

d(0,3) = d(0,1) + c13 = 5 + 1 = 6
d(0,4) = min{d(0,1) + c14, d(0,2) + c24} = min{8,11} = 8
d(0,5) = min{d(0,1) + c15, d(0,2) + c25} = min{11,10} = 10
d(0,6) = d(0,2) + c26 = 9

d(0,7) = min{d(0,3)+c37, d(0,4)+c47} = min{12,11} = 11
d(0,8) = min{d(0,3)+c38, d(0,4)+c48, d(0,5)+c58, d(0,6)+c68} = min{14,13,13,17} = 13
d(0,9) = min{d(0,5)+c59, d(0,6)+c69} = min{13,13} = 13

d(0,10) = min{d(0,7)+c7,10, d(0,8)+c8,10, d(0,9)+c9,10} = min{14,18,19} = 14
d(0,11) = min{d(0,7)+c7,11, d(0,8)+c8,11, d(0,9)+c9,11} = min{16,15,19} = 15

d(0,12) = min{d(0,10)+c10,12, d(0,11)+c11,12} = min{18,18} = 18
最短路径：
0-1-4-7-10-12
0-1-4-8-11-12
0-2-5-8-11-12
3.0/1背包问题
分析：
s	1	2	3	4	5
w	3	2	1	4	5
v	25	20	15	40	50
填表：
V(i,j)	0	1	2	3	4	5	6
  0		0	0	0	0	0	0	0
  1		0	0	0	25	25	25	25
  2		0	0	20	25	25	45	45
  3		0	15	20	35	40	45	60
  4		0	15	20	35	40	55	60
  5		0	15	20	35	40	55	65
  
V(0,j) = 0, 0 <= j <= 6; V(i,0) = 0, 0 <= i <= 5;

V(1,1) = V(0,1) = 0, 1<3;
V(1,2) = V(0,2) = 0, 2<3;
V(1,3) = max{V(0,3), V(0,0)+v[1]} = max{0,25} = 25, 3>=3;
V(1,4) = max{V(0,4), V(0,1)+v[1]} = max{0,25} = 25, 4>=3;
V(1,5) = max{V(0,5), V(0,2)+v[1]} = max{0,25} = 25, 5>=3;
V(1,6) = max{V(0,6), V(0,3)+v[1]} = max{0,25} = 25, 6>=3;

V(2,1) = V(1,1) = 0, 1<2;
V(2,2) = max{V(1,2), V(1,0)+v[2]} = max{0,20} = 20, 2>=2;
V(2,3) = max{V(1,3), V(1,1)+v[2]} = max{25,20} = 25, 3>=2;
V(2,4) = max{V(1,4), V(1,2)+v[2]} = max{25,20} = 25, 4>=2;
V(2,5) = max{V(1,5), V(1,3)+v[2]} = max{25,45} = 45, 5>=2;
V(2,6) = max{V(1,6), V(1,4)+v[2]} = max{25,45} = 45, 6>=2;

V(3,1) = max{V(2,1), V(2,0)+v[3]} = max{0,15} = 15, 1>=1;
V(3,2) = max{V(2,2), V(2,1)+v[3]} = max{20,15} = 20, 2>=1;
V(3,3) = max{V(2,3), V(2,2)+v[3]} = max{25,35} = 35, 3>=1;
V(3,4) = max{V(2,4), V(2,3)+v[3]} = max{25,40} = 40, 4>=1;
V(3,5) = max{V(2,5), V(2,4)+v[3]} = max{45,40} = 45, 5>=1;
V(3,6) = max{V(2,6), V(2,5)+v[3]} = max{45,60} = 60, 6>=1;

V(4,1) = V(3,1) = 15, 1<4;
V(4,2) = V(3,2) = 20, 2<4;
V(4,3) = V(3,3) = 35, 3<4;
V(4,4) = max{V(3,4), V(3,0)+v[4]} = max{40,40} = 40, 4>=4;
V(4,5) = max{V(3,5), V(3,1)+v[4]} = max{45,55} = 55, 5>=4;
V(4,6) = max{V(3,6), V(3,2)+v[4]} = max{60,60} = 60, 6>=4;

V(5,1) = V(4,1) = 15, 1<5;
V(5,2) = V(4,2) = 20, 2<5;
V(5,3) = V(4,3) = 35, 3<5;
V(5,4) = V(4,4) = 40, 4<5;
V(5,5) = max{V(4,5), V(4,0)+v[5]} = max{55,50} = 55;
V(5,6) = max{V(4,6), V(4,1)+v[5]} = max{55,65} = 65;
结果：V(5,6) = 65, 选择：3，5

4.最长公共子序列问题
A = "xzyzzyx"	
B = "zxyyzxz"
填表：
len(i,j)	0	1	2	3	4	5	6	7		st(i,j)	0	1	2	3	4	5	6	7
  0			0	0	0	0	0	0	0	0			0	0	0	0	0	0	0	0	0
  1			0	0	1	1	1	1	1	1			1	0	2	1	2	2	2	1	2
  2			0	1	1	1	1	2	2	2			2	0	1	2	2	2	1	2	1
  3			0	1	1	2	2	2	2	2			3	0	3	2	1	1	2	2	2
  4			0	1	1	2	2	3	3	3			4	0	1	2	3	2	1	2	1
  5			0	1	1	2	2	3	3	4			5	0	1	2	3	2	1	2	1	
  6			0	1	2	2	3	3	3	4			6	0	3	2	1	1	2	2	3
  7			0	1	2	2	3	3	4	4			7	0	3	1	2	3	2	1	2
  
len(1,1) = 0, A[0]!=B[0],len(1,0)==0>=len(1,0)==0; 	st(1,1)=2;
len(1,2) = 1, A[0]==B[1],len(0,1) + 1 = 1; 			st(1,2)=1;
len(1,3) = 1, A[0]!=B[2],len(1,2)==1>=len(0,3)==0; 	st(1,3)=2;
len(1,4) = 1, A[0]!=B[3],len(1,3)==1>=len(0,4)==0; 	st(1,4)=2;
len(1,5) = 1, A[0]!=B[4],len(1,4)==1>=len(0,5)==0; 	st(1,5)=2;
len(1,6) = 1, A[0]==B[5],len(0,5) + 1 = 1; 			st(1,6)=1;
len(1,7) = 1, A[0]!=B[6],len(1,6)==1>=len(0,7)==0; 	st(1,7)=2;

len(2,1) = 1, A[1]==B[0],len(1,0) + 1 = 1; 			st(2,1)=1;
len(2,2) = 1, A[1]!=B[1],len(2,1)==1>=len(1,2)==1; 	st(2,2)=2;
len(2,3) = 1, A[1]!=B[2],len(2,2)==1>=len(1,3)==1; 	st(2,3)=2;
len(2,4) = 1, A[1]!=B[3],len(2,3)==1>=len(1,4)==1; 	st(2,4)=2;
len(2,5) = 2, A[1]==B[4],len(1,4) + 1 = 2; 			st(2,5)=1;
len(2,6) = 2, A[1]!=B[5],len(2,5)==2>=len(1,6)==1;	st(2,6)=2;
len(2,7) = 2, A[1]==B[6],len(1,6) + 1 = 2;			st(2,7)=2;

len(3,1) = 1, A[2]!=B[0],len(3,0)==0<len(2,1)==1;	st(3,1)=3;
len(3,2) = 1, A[2]!=B[1],len(3,1)==1>=len(2,2)==1;	st(3,2)=2;
len(3,3) = 2, A[2]==B[2],len(2,2) + 1 = 2;			st(3,3)=1;
len(3,4) = 2, A[2]==B[3],len(2,3) + 1 = 2;			st(3,4)=1;
len(3,5) = 2, A[2]!=B[4],len(3,4)==2>=len(2,5)==2;	st(3,2)=2;
len(3,6) = 2, A[2]!=B[5],len(3,5)==2>=len(2,6)==2;	st(3,2)=2;
len(3,7) = 2, A[2]!=B[6],len(3,6)==2>=len(2,7)==2;	st(3,2)=2;

len(4,1) = 1, A[3]==B[0],len(3,0) + 1 = 1;			st(4,1)=1;
len(4,2) = 1, A[3]!=B[1],len(4,1)==1>=len(3,2)==1;	st(4,2)=2;
len(4,3) = 2, A[3]!=B[2],len(4,2)==1<len(3,3)==2;	st(4,3)=3;
len(4,4) = 2, A[3]!=B[3],len(4,3)==2>=len(3,4)==2;  st(4,4)=2;
len(4,5) = 3, A[3]==B[4],len(3,4) + 1 = 3;			st(4,5)=1;
len(4,6) = 3, A[3]!=B[5],len(4,5)==3>=len(3,6)==2;	st(4,6)=2;
len(4,7) = 3, A[3]==B[6],len(3,6) + 1 = 3;			st(4,7)=1;

len(5,1) = 1, A[4]==B[0],len(4,0) + 1 = 1;			st(5,1)=1;
len(5,2) = 1, A[4]!=B[1],len(5,1)==1>=len(4,2)==1;	st(5,2)=2;
len(5,3) = 2, A[4]!=B[2],len(5,2)==1<len(4,3)==2;	st(5,3)=3;
len(5,4) = 2, A[4]!=B[3],len(5,3)==2>=len(4,4)==2;	st(5,4)=2;
len(5,5) = 3, A[4]==B[4],len(4,4) + 1 = 3;			st(5,5)=1;
len(5,6) = 3, A[4]!=B[5],len(5,5)==3>=len(4,6)==3;	st(5,6)=2;
len(5,7) = 4, A[4]==B[6],len(4,6) + 1 = 4;			st(5,7)=1;

len(6,1) = 1, A[5]!=B[0],len(6,0)==0<len(5,1)==1;	st(6,1)=3;
len(6,2) = 2, A[5]!=B[1],len(6,1)==1>=len(5,2)==1;	st(6,2)=2;
len(6,3) = 2, A[5]==B[2],len(5,2) + 1 = 2;			st(6,3)=1;
len(6,4) = 3, A[5]==B[3],len(5,3) + 1 = 3;			st(6,4)=1;
len(6,5) = 3, A[5]!=B[4],len(6,4)==3>=len(5,5)==3;	st(6,5)=2;
len(6,6) = 3, A[5]!=B[5],len(6,5)==3>=len(5,6)==3;	st(6,6)=2;
len(6,7) = 4, A[5]!=B[6],len(6,6)==3<len(5,7)==4;	st(6,7)=3;

len(7,1) = 1, A[6]!=B[0],len(7,0)==0<len(6,1)==1;	st(7,1)=3;
len(7,2) = 2, A[6]==B[1],len(6,1) + 1 = 2;			st(7,2)=1;
len(7,3) = 2, A[6]!=B[2],len(7,2)==2>=len(6,3)==2;	st(7,3)=2;
len(7,4) = 3, A[6]!=B[3],len(7,3)==2<len(6,4)==3;	st(7,4)=3;
len(7,5) = 3, A[6]!=B[4],len(7,4)==3>=len(6,5)==3;	st(7,5)=2;
len(7,6) = 4, A[6]==B[5],len(6,5) + 1 = 4;			st(7,6)=1;
len(7,7) = 4, A[6]!=B[6],len(7,6)==4>=len(6,7)==4;	st(7,7)=2;

5.K-近似匹配
P = "grammer"
T = "grameer"
填表：
D(i,j)	0	1	2	3	4	5	6	7
	0	0	1	2	3	4	5	6	7
	1	1	0	1	2	3	4	5	6
	2	2	1	0	1	2	3	4	5
	3	3	2	1	0	1	2	3	4
	4	4	3	2	1	0	1	2	3
	5	5	4	3	2	1	1	2	3
	6	6	5	4	3	2	1	1	2
	7	7	6	5	4	3	2	2	1
D(0,j) = j, D(i,0) = i;

D(1,1) = min{D(0,0),D(0,1)+1,D(1,0)+1} = min{0,2,2} = 0, 	P[0]==T[0];
D(1,2) = min{D(0,1)+1,D(0,2)+1,D(1,1)+1} = min{2,3,1} = 1, 	P[0]!=T[1];
D(1,3) = min{D(0,2)+1,D(0,3)+1,D(1,2)+1} = min{3,4,2} = 2,	P[0]!=T[2];
D(1,4) = min{D(0,3)+1,D(0,4)+1,D(1,3)+1} = min{4,5,3} = 3,	P[0]!=T[3];
D(1,5) = min{D(0,4)+1,D(0,5)+1,D(1,4)+1} = min{5,6,4} = 4,	P[0]!=T[4];
D(1,6) = min{D(0,5)+1,D(0,6)+1,D(1,5)+1} = min{6,7,5} = 5,	P[0]!=T[5];
D(1,7) = min{D(0,6)+1,D(0,7)+1,D(1,6)+1} = min{7,8,6} = 6,	P[0]!=T[6];

D(2,1) = min{D(1,0)+1,D(1,1)+1,D(2,0)+1} = min{2,1,3} = 1,	P[1]!=T[0];
D(2,2) = min{D(1,1),D(1,2)+1,D(2,1)+1} = min{0,2,2} = 0,	P[1]==T[1];
D(2,3) = min{D(1,2)+1,D(1,3)+1,D(2,2)+1} = min{2,3,1} = 1,	P[1]!=T[2];
D(2,4) = min{D(1,3)+1,D(1,4)+1,D(2,3)+1} = min{3,4,2} = 2,	P[1]!=T[3];
D(2,5) = min{D(1,4)+1,D(1,5)+1,D(2,4)+1} = min{4,5,3} = 3,	P[1]!=T[4];
D(2,6) = min{D(1,5)+1,D(1,6)+1,D(2,5)+1} = min{5,6,4} = 4,	P[1]!=T[5];
D(2,7) = min{D(1,6),D(1,7)+1,D(2,6)+1} = min{5,7,5} = 5,	P[1]==T[6];

D(3,1) = min{D(2,0)+1,D(2,1)+1,D(3,0)+1} = min{3,2,4} = 2,	P[2]!=T[0];
D(3,2) = min{D(2,1)+1,D(2,2)+1,D(3,1)+1} = min{2,1,3} = 1,	P[2]!=T[1];
D(3,3) = min{D(2,2),D(2,3)+1,D(3,2)+1} = min{0,2,2} = 0,	P[2]==T[2];
D(3,4) = min{D(2,3)+1,D(2,4)+1,D(3,3)+1} = min{2,3,1} = 1,	P[2]!=T[3];
D(3,5) = min{D(2,4)+1,D(2,5)+1,D(3,4)+1} = min{3,4,2} = 2,	P[2]!=T[4];
D(3,6) = min{D(2,5)+1,D(2,6)+1,D(3,5)+1} = min{4,5,3} = 3,	P[2]!=T[5];
D(3,7) = min{D(2,6)+1,D(2,7)+1,D(3,6)+1} = min{5,6,4} = 4,	P[2]!=T[6];

D(4,1) = min{D(3,0)+1,D(3,1)+1,D(4,0)+1} = min{4,3,5} = 3,	P[3]!=T[0];
D(4,2) = min{D(3,1)+1,D(3,2)+1,D(4,1)+1} = min{3,2,4} = 2,	P[3]!=T[1];
D(4,3) = min{D(3,2)+1,D(3,3)+1,D(4,2)+1} = min{2,1,3} = 1,	P[3]!=T[2];
D(4,4) = min{D(3,3),D(3,4)+1,D(4,3)+1} = min{0,2,2} = 0,	P[3]==T[3];
D(4,5) = min{D(3,4)+1,D(3,5)+1,D(4,4)+1} = min{2,3,1} = 1,	P[3]!=T[4];
D(4,6) = min{D(3,5)+1,D(3,6)+1,D(4,5)+1} = min{3,4,2} = 2,	P[3]!=T[5];
D(4,7) = min{D(3,6)+1,D(3,7)+1,D(4,6)+1} = min{4,5,3} = 3,	P[3]!=T[6];

D(5,1) = min{D(4,0)+1,D(4,1)+1,D(5,0)+1} = min{5,4,6} = 4,	P[4]!=T[0];
D(5,2) = min{D(4,1)+1,D(4,2)+1,D(5,1)+1} = min{4,3,5} = 3,	P[4]!=T[1];
D(5,3) = min{D(4,2)+1,D(4,3)+1,D(5,2)+1} = min{3,2,4} = 2,	P[4]!=T[2];
D(5,4) = min{D(4,3),D(4,4)+1,D(5,3)+1} = min{1,1,3} = 1,	P[4]==T[3];
D(5,5) = min{D(4,4)+1,D(4,5)+1,D(5,4)+1} = min{1,2,2} = 1,	P[4]!=T[4];
D(5,6) = min{D(4,5)+1,D(4,6)+1,D(5,5)+1} = min{2,3,2} = 2,	P[4]!=T[5];
D(5,7) = min{D(4,6)+1,D(4,7)+1,D(5,6)+1} = min{3,4,3} = 3,	P[4]!=T[6];

D(6,1) = min{D(5,0)+1,D(5,1)+1,D(6,0)+1} = min{6,5,7} = 5,	P[5]!=T[0];
D(6,2) = min{D(5,1)+1,D(5,2)+1,D(6,1)+1} = min{5,4,6} = 4,	P[5]!=T[1];
D(6,3) = min{D(5,2)+1,D(5,3)+1,D(6,2)+1} = min{4,3,5} = 3,	P[5]!=T[2];
D(6,4) = min{D(5,3)+1,D(5,4)+1,D(6,3)+1} = min{3,2,4} = 2,	P[5]!=T[3];
D(6,5) = min{D(5,4),D(5,5)+1,D(6,4)+1} = min{1,2,3} = 1,	P[5]==T[4];
D(6,6) = min{D(5,5),D(5,6)+1,D(6,5)+1} = min{1,3,2} = 1,	P[5]==T[5];
D(6,7) = min{D(5,6)+1,D(5,7)+1,D(6,6)+1} = min{3,4,2} = 2,	P[5]!=T[6];

D(7,1) = min{D(6,0)+1,D(6,1)+1,D(7,0)+1} = min{7,6,8} = 6,	P[6]!=T[0];
D(7,2) = min{D(6,1),D(6,2)+1,D(7,1)+1} = min{5,5,7} = 5,	P[6]==T[1];
D(7,3) = min{D(6,2)+1,D(6,3)+1,D(7,2)+1} = min{5,4,6} = 4,	P[6]!=T[2];
D(7,4) = min{D(6,3)+1,D(6,4)+1,D(7,3)+1} = min{4,3,5} = 3,	P[6]!=T[3];
D(7,5) = min{D(6,4)+1,D(6,5)+1,D(7,4)+1} = min{3,2,4} = 2,	P[6]!=T[4];
D(7,6) = min{D(6,5)+1,D(6,6)+1,D(7,5)+1} = min{2,2,3} = 2,	P[6]!=T[5];
D(7,7) = min{D(6,6),D(6,7)+1,D(7,6)+1} = min{1,3,3} = 1,	P[6]==T[6];

6.最优二叉查找树
分析：使用递归算法可以达到线性时间
c++实现：
void CreatTree(const vector<Record> &rd, int s, int t, const vector<vector<int>> &R, TNode* &root)
{
	if(s == t)
		return;
	else{
		int k = R[s][t];
		root = new TNode{rd[k].ch,NULL,NULL};
		CreatTree(rd,s,k,R,root->lchild);
		CreatTree(rd,k+1,t,R,root->rchild);
	}
}
7.Ackermann函数
c++实现：（网上找的，没看懂）
用两个一维数组，ind[i]和val[i]，使得当ind[i]等于t时，val[i]=A(i，ind[i])。
i             ind[i]              val[i]
0            	0                  	1
1            	-1                	0	
2            	-1                	0
……
初始时，令ind[0]=0，val[0]=1，ind[i]=-1(i>0)，val[i]=0(i>0)。
1当m=0时，A(m，n)=n+1。
任给一个t，当ind[0]=t时，能够求出val[0]的值，val[0]等于ind[0]。
2当n=0，m>0时，A(m，n)=n+1。
能够求出当ind[i]=0时，val[i]的值，此时val[i]等于当ind[i-1]等于1时val[i-1]的值。
3当m>0，n>0时，A(m，n)=A(m-1，A(m，n-1))。
当ind[i]=t，val[i]=s时，要求当ind[i]’=t+1时val[i]’的值。
Val[i]’=A(i，ind[i]’)=A(i-1，A(i，ind[i]’-1)=A(i-1，A(i，ind[i]))=A(i-1，val[i])
所以，当ind[i-1]=val[i]时，能够求出当ind[i]’=k+1时，val[i]’=val[i-1]。
 
#include <stdio.h>
int ack(int& m,int& n)
{
       int i,j;
       int *val=new int[m+1];
       int *ind=new int[m+1];
       for(i=1;i<=m;i++)
       {
              ind[i]=-1;
              val[i]=-1;
       }
       ind[0]=0;
       val[0]=1;
       while(ind[m]<n)
       {
              val[0]++;
              ind[0]++;
              printf("%d ",val[0]);
              for(j=1;j<=m;j++)
              {
                     if(1==ind[j-1])
                     {
                            val[j]=val[j-1];
                            ind[j]=0;
                     }
                     if(val[j]!=ind[j-1])
                            break;
                     ind[j]++;
                     val[j]=val[j-1];
              }
       }
       printf("/n");
       printf("    i   ind[i] val[i]/n");
       for(i=0;i<=m;i++)
              printf("%5d %6d %6d/n",i,ind[i],val[i]);
       return val[m];
}
void main()
{
       int m,n,ak;
       printf("Ackmann(m,n)/nPlease enter m:");
       scanf("%d",&m);
       printf("Please enter n:");
       scanf("%d",&n);
       ak=ack(m,n);
       printf("the Ackmann(%d,%d) is %d/n",m,n,ak);
}
 
8.货币兑付问题
分析：动态规划函数：
	d(i,j)= /d(i-1,j),					j < vi;
			\min{d(i-1,j), d(i,j-vi)+1},j >= vi;	(vi为货币面值)
c++实现：
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int main()
{
	//需要支付的货币 
	int n;
	cout << "请输入需要支付的金额：" ; 
	cin >> n;
	//货币面值 
	vector<int> v = {1,2,5,10}; 
	int m = v.size();
	//选用货币个数
	vector<int> vn(m,0); 

	//动态规划表 
	vector<vector<int>> d(m+1,vector<int>(n+1,0));
	
	d[0].assign(n+1,-1);//d[i][j]==-1表示无解，即需要无穷多张 
	d[0][0] = 0;
	for(int i = 1; i <= m; ++i){
		for(int j = 1; j <= n; ++j){
			if(j < v[i-1]){
				d[i][j] = d[i-1][j];
			}
			else{
				if(d[i-1][j] == -1)
					d[i][j] = d[i][j-v[i-1]]+1;
				else if(d[i][j-v[i-1]] == -1)
					d[i][j] = d[i-1][j];
				else
					d[i][j] = min(d[i-1][j],d[i][j-v[i-1]]+1); 
			}
		}
	} 
	cout << "动态规划表：" << endl;
	for(int i = 0; i <= m; ++i){
		for(int j = 0; j <= n; ++j)
			cout << d[i][j] << "	"; 
		cout << endl;
	}
	
	
	cout << "选择的货币：" << endl;
	for(int i = m,j = n; i >0; ){
		if(d[i][j] == d[i-1][j])
			--i;
		else{
			++vn[i-1];
			j -= v[i-1];
		}
	}
	cout << "\t面值\t个数" << endl;
	for(int i = 0; i < m; ++i){
		cout << "\t" << v[i] << "\t" << vn[i] << endl;
	}
	cout << "最少货币数：" << d[m][n] << endl; 
	return 0;
}		
时间、空间复杂度都为O(m*n)。	
9.多边形游戏
分析：（摘自https://blog.csdn.net/GailyYelp/article/details/60817140）
	所有边依次用整数从1到n编号。
　　游戏第1步，将一条边删除。
　　随后n-1步按以下方式操作：
　　(1)选择一条边E以及由E连接着的2个顶点V1和V2；
　　(2)用一个新的顶点取代边E以及由E连接着的2个顶点V1和V2。将由顶点V1和V2的整数值通过边E上的运算得到的结果赋予新顶点。
　　最后，所有边都被删除，游戏结束。游戏的得分就是所剩顶点上的整数值。
算法：
	设所给定的多边形的顶点和边的顺时针序列位 op[0],v[0],op[1],v[1],….,op[n-1],v[n-1],其中，op[i]表示第i条边所对应的运算符，
v[i]表示第i个顶点上的数值，i=0~n-1。
	在所给多边形中，从顶点i(0<=i<=n-1)开始，长度为j的（链中有j个顶点）的顺时针链p(i,j)可以表示为： 
v[i],op[i+1],v[i+1],op[i+2],……,v[i+j-1];
	如果这条链的最后一次合并运算在op[i+s]处发生(0<s<j),则可在op[i+s]处将链分为两个子链p(i,s)和p(i+s,j-s);
	设m1是对子链p(i,s)的任意一种合并方式得到的值，而a和b分别是在所有可能的合并中得到的最小值和最大值。
m2是子链p(i+s,j-s)的任意一种合并方式得到的值，而c和d分别是在所有的可能的合并中得到的最小值和最大值。依次定义有a<=m1<=b,c<=m2<=d;
	由于子链p(i,s)和p(i+s,j-s)的合并方式决定了p(i，j）在op[i+s]（为符号+或*）处断开后的合并方式，在op[i+s]处合并后的值为m=(m1)op[i+s](m2); 
	(1)当op[i+s]=’+’时，显然有a+c≤m≤b+d 
	(2)当op[i+s]=’*’时，有min{ac，ad，bc，bd}≤m≤max{ac，ad，bc，bd}
c++实现：
#include<iostream>
#include<vector>
#include<algorithm>
#include<limits>

using namespace std;

int main()
{
	vector<char> op = {'+','+','*','*'};
	vector<int> v = {-7,4,2,5};
	int n = v.size();
	vector<vector<vector<int>>> d(n,vector<vector<int>>(n+1,vector<int>(2,0)));
	for(int i = 0; i < n; ++i){
		d[i][1][0] = v[i];
		d[i][1][1] = v[i];
	}
	for(int j = 2; j <= n; ++j){
		for(int i = 0; i < n; ++i){
			int minl,maxl,minr,maxr;
			int mi = numeric_limits<int>::max();
			int ma = numeric_limits<int>::min();			
			for(int k = 1; k < j; ++k){
				minl = d[i][k][0];
				maxl = d[i][k][1];
				minr = d[(i+k)%n][j-k][0];
				maxr = d[(i+k)%n][j-k][1];
				if(op[(i+k)%n] == '+'){
					if(mi > minl + minr)
						mi = minl + minr;
					if(ma < maxl + maxr)
						ma = maxl + maxr;
				}
				else{
					int t = std::min({minl*minr, minl*maxr, maxl*minr, maxl*maxr});
					if(mi > t)
						mi = t;
					t = std::max({minl*minr, minl*maxr, maxl*minr, maxl*maxr});
					if(ma < t)
						ma = t;
				}
			}
			d[i][j][0] = mi;
			d[i][j][1] = ma;
		}
	}
	
	int rt = numeric_limits<int>::min();
	for(int i = 0; i < n; ++i){
		if(rt < d[i][n][1])
			rt = d[i][n][1];
	}
	cout << "游戏最高得分：" << rt << endl;
	return 0;
}