习题一
1.七桥问题
解答：抽象：求经过图中每条边一次且仅一次的回路，即欧拉回路
欧拉回路的判定规则：
（1）如果通奇数桥的城区多于两个，则不存在欧拉回路；
（2）如果只有两个城区通奇数桥，则可以从这两个城区之一出发找到欧拉回路；
（3）如果没有一个城区通奇数桥，则无论从哪里出发都能找到欧拉回路。
总结：只有0个或两个城区通奇数桥，则存在欧拉回路。
2.更相减损术
伪代码：
	输入：两个自然数m和n
	输出：m和n的最大公约数
	1.循环直到m = n
		1.1如果m>n,m = m - n;
		1.2否则，n = n - m;
	2.输出m；
3.最接近数之差
伪代码：
	输入：数组v
	输出：数组v中相差最小两个元素（最接近数）之差
	1.对数组v进行快速排序
	2.遍历数组求相邻两元素之差的绝对值，找到最小值min
	3.返回min
c++代码：
	prac1.3.cpp
	#include<iostream>
	#include<vector>
	#include<algorithm>

	using namespace std;

	int MinDis(vector<int> &v)
	{
		if(v.size() == 0 || v.size() == 1)
			return -1;
		vector<int> a = v;
		sort(a.begin(),a.end());
		int min = abs(a[1] - a[0]);
		int n = a.size();
		int t;
		for(int i = 2; i < n; ++i){
			t = abs(a[i] - a[i-1]);
			if(t < min)
				min = t;
		}
		return min;
	}
	int main()
	{
		vector<int> v = {4, 3, 9, 1, 6};
		cout << "数组：";
		for(auto i : v)
			cout << i << " ";
		cout << endl;
		cout << "最接近数之差：" << MinDis(v) << endl;
		return 0;
	}

4.找出数组a[n]中一个既不是最大也不是最小的元素
伪代码：
	输入：数组a
	输出：a[n]中一个既不是最大也不是最小的元素
	1.比较a[0]与a[1],将较小者赋值给min，较大者赋值给max；
	2.从第三个元素a[2]开始循环至数组最后一个元素
		2.1如果a[2]与min或max相等，跳过此次循环，进入下个元素；
		2.2如果a[2]小于min，返回min；
		2.3如果a[2]大于max，返回max；
		2.4如果a[2]在min与max之间，返回a[2];
	3.所求不存在
最坏情况：需2n+1次比较
c++代码：略

5.求n至少为多大时，n个1组成的整数能被2013整除。
c++代码：
	#include<iostream>
	using namespace std;
	int main()
	{
		int v = 11111;
		int n = 5;
		while(v%2013 != 0){
			v = (v%2013) * 10 + 1;
			++n;
		}
		cout << n << endl;
		return 0;
	}
代码详解:
		以上代码的核心其实就是判断1,11,111等N位数能否被n整除，也就是sum=sum*10+1。
	但是考虑到最大值边界问题，于是将上述公式换为了sum= (sum % n)*10+1。
	之所以能这样转换，是因为: (举例)
	譬如判断 111是否能被3整除，可以是 (1*10+1)*10+1
	也可以是判断
	第一步: 1%3=1 (1整除3的余数为1）
	第二步: 11%3=2 (11整除3的余数为2）
	第三步: 21%3=0 (符合条件)
		换一个思路，假如判断(8+7)是否能被3整除，那么我们只需要现将它们能被3整除的部分去除调，
	用余数累加起来判断即可，也就是说只需要判断2+1能否被3整除即可
网上找到的一个数论分析：（更新部分没看懂）
	费马小定理简介
	首先得知道的是，费马小定理是欧拉定理的一种特殊情况，欧拉定理描述的是关于同余的性质，而费马定理如下:
	假如a是整数，p是质数，且a，p互质(两者只有一个公约数1)，那么a的(p-1)次方除以p的余数恒等于1
	即a^(p-1)%p=1

	费马小定理在本题中的应用
	关键来了，本题与费马小定理有什么关系呢？

	如上楼中有人提到，本题中，2013=3*11*61，所以需要满足
	能被3整除
	能被11整除
	能被61整除
	而前两者很容易就根据下面的条件判断出:
	若一个整数的数字和能被3整除，则这个整数能被3整除。
	若一个整数的奇位数字之和与偶位数字之和的差能被11整除，则这个数能被11整除。
	因此马上就可以将条件转换为:
	n得是3的倍数(因为n个1加起来要是3的倍数)
	n得是2的倍数(奇位和偶数直接的差为0)
	因此n是6的倍数
	n个1这个数(x)能被61整除
	接下来就剩下了一个问题: n个1能被61整除，需要满足什么？接下来费马小定理就派得上用处了。

	我们可以得知: 61和10互素。
	所以套用上述的公式，可以得出: 10^(60)%61=1
	所以:10^(60)-1=0 (mod 61)
	而10^60 -1 就是60个9组成的数，也就是说 60个9组成的数能够被61整除。
	那么自然60个1组成的数能够被61整除(因为61与3无关)，同时60又是6的倍数，因此满足条件。

	更新，之前有不严谨之处
	继续判断，60的符合条件的约数(6的倍数)有，6，12，30，60。
	检查计算得出后可以知道只有60满足条件。

	因此得出了结论: n至少为60时，n个1组成的数能够被2013整除

6.求满足给定精度要求的PI值
c++代码：
	#include<iostream>
	#include<cmath>
	using namespace std;
	const double E = 0.000001;
	int main()
	{
		int i = 3;
		double x = 1;
		double pi;
		do{
			pi = i * x;
			x = sqrt(2 - 2 * sqrt(1 - (x/2)*(x/2)));
			i = i << 1;
		}while(i * x - pi > E);
		cout << pi << endl;
		return 0;
	}

7.判断给定数是否是完美数
c++代码：
	#include<iostream>
	using namespace std;
	bool IsPerfectNum(int n)
	{
		int sum = 0;
		for(int i = 1; i < n; ++i){
			if(n%i == 0)
				sum += i;
		}
		return n==sum;
	}
	int main()
	{
		int n;
		cin >> n;
		cout << (IsPerfectNum(n)?"是完美数":"不是完美数") << endl;
		return 0;
	}
8.
	由于甲过桥时间最短，那么每次传递手电的工作应有甲完成
	甲每次分别带着乙丙丁过桥
	例如：
	第一趟：甲，乙过桥且甲回来
	第二趟：甲，丙过桥且甲回来
	第一趟：甲，丁过桥
	一共用时19小时
9.
	设最初两个数较大的为a, 较小的为b，两个数的最大公约数为factor。
则最终能出现的数包括: factor, factor*2, factor*3, ..., factor*(a/factor)=a. 一共a/factor个。
如果a/factor 是奇数，就选择先行动；否则就后行动。
